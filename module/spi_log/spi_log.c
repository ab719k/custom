
/*****************************************************************************/
/*                              Legal                                        */
/*****************************************************************************/

/*
** Copyright ©2015-2017. Lantronix, Inc. All Rights Reserved.
** By using this software, you are agreeing to the terms of the Software
** Development Kit (SDK) License Agreement included in the distribution package
** for this software (the “License Agreement”).
** Under the License Agreement, this software may be used solely to create
** custom applications for use on the Lantronix xPico Wi-Fi product.
** THIS SOFTWARE AND ANY ACCOMPANYING DOCUMENTATION IS PROVIDED "AS IS".
** LANTRONIX SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED
** TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS
** FOR A PARTICULAR PURPOSE.
** LANTRONIX HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
** ENHANCEMENTS, OR MODIFICATIONS TO THIS SOFTWARE.
** IN NO EVENT SHALL LANTRONIX BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
** SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
** ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
** LANTRONIX HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*****************************************************************************/
/*                           Documentation                                   */
/*****************************************************************************/

/*!
** \addtogroup example
** @{
*/

/*!
** \defgroup spi_log spi_log
** @{
**
** The \b spi_log module implements implements a rudimentary "SPI Protocol".
** When this protocol is chosen by a SPI, it logs whatever it receives on the
** SPI.
**
** Build it from project "spiLogDemo".
**
** To run it you will need to select protocol "Log" under SPI Configuration.
**
** Also, you will need to enable the SPI CPs: Under CPM Roles Configuration,
** enable the SPI group of CPs.
** HINT: If using the evaluation board, you may place a jumper between JP5
** pins CP3 and CP4 to effect a loopback of your SPI data.
** Note that the SPI group of CPs is ganged, so when you enable one, you
** enable them all.
** Also note that all the other CPM Roles referring to any of the SPI CPs must
** be disabled.
*/

/*****************************************************************************/
/*                             Includes                                      */
/*****************************************************************************/

#include <stdio.h> /* MinGW plus Lantronix changes, delivered with SDK. */
#include <string.h> /* MinGW, delivered with SDK. */

#include "adc_definitions.h" /* For ADC chipset */
#include "ltrx_compile_defines.h" /* Delivered with SDK. */
#include "ltrx_spi.h" /* Delivered with SDK. */
#include "ltrx_cpm.h" /* Delivered with SDK. */
#include "ltrx_tlog.h" /* Delivered with SDK. */
#include "spi_log_module_defs.h" /* Automatically generated by make. */
//#include "cp2120.h"

/*****************************************************************************/
/*                              Defines                                      */
/*****************************************************************************/

//#define MAX_TRANSFER_LENGTH 20
#define MAX_TRANSFER_LENGTH 32
void my_spi_interrupt(void) ;

static const struct ltrx_cpm_role s_role = {
	.name = "SPI_INT",
    .helpHtml = "SPI_INT",
	.optOneBasedCp = 2, // CP2
	.optToggleCall = (void *)my_spi_interrupt,
	.usage = LTRX_CPM_ROLE_USAGE__INPUT
};


#ifdef ADC_VARS
int32_t channel_data[8];
uint8_t controlTable[256];
uint8_t recBuffer[36];
uint8_t dummy_send[36];
uint8_t sar_recBuffer[10];

#endif

char txBuffer[MAX_TRANSFER_LENGTH];
uint8_t rxBuffer[MAX_TRANSFER_LENGTH];
struct ltrx_spi_descriptor lsd;
static bool setup_spi = false;


/*****************************************************************************/
/*                             Structs                                       */
/*****************************************************************************/

struct thread_info
{
    uint32_t zeroBasedIndex;
    bool isRunning;
};

/*****************************************************************************/
/*                            Prototypes                                     */
/*****************************************************************************/

bool StartSpiLog(uint16_t zeroBasedIndex);

void StopSpiLog(uint16_t zeroBasedIndex);



/*****************************************************************************/
/*                         Local Constants                                   */
/*****************************************************************************/

static const struct ltrx_spi_protocol s_spiProtocol = {
	.protocolName  = "SPI_ADC",
    .helpHtml = "SDK xPico IPS.",
	.startProtocol = StartSpiLog,
	.stopProtocol  = StopSpiLog
};

/*****************************************************************************/
/*                         Local Variables                                   */
/*****************************************************************************/

static struct thread_info *s_threadInfo[MAX_SPI_EXTERNAL];

static struct ltrx_thread *s_threadForSpi[MAX_SPI_EXTERNAL];

static uint16_t zIndex=0;

/*****************************************************************************/
/*                               Code                                        */
/*****************************************************************************/

void spi_log_module_registration(void)
{
	/*
Register your module. 
Register your module in its initialization, before running any of your code. 
Parameters
[in]
lmi
Registration information. Refer to structure generated by make: &g_<module_name>ModuleInfo
Where <module_name> is the name of your module. 	
	*/
    ltrx_module_register(&g_spi_logModuleInfo);
    ltrx_spi_register_protocol(&s_spiProtocol);
}

void spi_log_module_startup(void)
{
}


void my_spi_interrupt(void) {
	struct thread_info *ti;
    //ltrx_preemption_block();
    ti = s_threadInfo[zIndex];
    if(ti && ti->isRunning)
    {
		uint8_t dummy_send[36]={0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x4E,
			0xC3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x4E, 0xC3, 0};
			
		memcpy(txBuffer, dummy_send,36);
		lsd.data_bytes=36;
		lsd.mosi_buf = (void *)txBuffer;
		lsd.miso_buf = rxBuffer;
		ltrx_spi_transfer(ti->zeroBasedIndex, &lsd);
		TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, " my_spi_interrupt: Sent \"%s\"", txBuffer);
		TLOG_HEXDUMP(TLOG_SEVERITY_LEVEL__INFORMATIONAL, rxBuffer, lsd.data_bytes, NULL);		
    } else {
		TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, " my_spi_interrupt: ti not running");
	}
	//ltrx_preemption_unblock();

}
/*
Send command using Lantronix SPI API
*/
//Send a command to both chained A04 devices when the word length is 1 with each word having a size of 3 bytes.
static void sendCommand(struct thread_info *ti, int16_t command) {
	//lsd.data_bytes = snprintf(txBuffer, sizeof(txBuffer), "%x",ADS131A04_UNCLOCK_COMMAND);
#if 0	
	bool isAsserted;
	int count = 0;
	uint16_t roleIndex = ltrx_cp_role_index_get(s_role.name);
#endif

    memcpy(txBuffer, &command,sizeof(int16_t));
    lsd.data_bytes=2;
	lsd.mosi_buf = (void *)txBuffer;
	lsd.miso_buf = rxBuffer;
    ltrx_spi_transfer(ti->zeroBasedIndex, &lsd);
    TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "Sent \"%s\"", txBuffer);
    TLOG_HEXDUMP(TLOG_SEVERITY_LEVEL__INFORMATIONAL, rxBuffer, lsd.data_bytes, NULL);
#if 0
    while (count < 9999) {
		ltrx_cp_read(roleIndex, &isAsserted);
    	if (isAsserted) { // read CP for interrupt
    		// Interrupt recieved
    		 TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "Interrupt recieved \"%s\"", rxBuffer);
    		return ;
    	} else {
    		count ++;
			// Interrupt Not recieved
    		
    	}
		//ltrx_thread_sleep(1);
    }
	TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "Interrupt Not recieved \"%s\"", rxBuffer);
#endif	
    return ;
}


//Send a command to both chained A04 devices when the word length is 6 with each word having a size of 3-bytes.
static void sendCommand_6words(struct thread_info *ti, int16_t command) {
	//lsd.data_bytes = snprintf(txBuffer, sizeof(txBuffer), "%x",ADS131A04_UNCLOCK_COMMAND);
#if 0		
	bool isAsserted;
	int count = 0;
	uint16_t roleIndex = ltrx_cp_role_index_get(s_role.name);
#endif
	TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL,"SPI: sendCommand_6words((%x))", command);
    memcpy(txBuffer,&command,sizeof(int16_t));
    lsd.data_bytes=2;
	lsd.mosi_buf = (void *)txBuffer;
	lsd.miso_buf = rxBuffer;
    ltrx_spi_transfer(ti->zeroBasedIndex, &lsd);
    TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "Sent \"%s\"", txBuffer);
    TLOG_HEXDUMP(TLOG_SEVERITY_LEVEL__INFORMATIONAL, rxBuffer, lsd.data_bytes, NULL);
#if 0
    while (count < 500) {
		ltrx_cp_read(roleIndex, &isAsserted);
    	if (isAsserted) { // read CP for interrupt
    		// Interrupt recieved
    		 TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "Interrupt recieved \"%s\"", rxBuffer);
			 ltrx_thread_sleep(1000);
    		return ;
    	} else {
    		// Interrupt recieved
    	}
		ltrx_thread_sleep(10);
		count ++;
    }
	TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "Interrupt Not recieved \"%s\"", rxBuffer);
#endif
	
    return ;
}


/*
 *  Snippet from Mail from Ralph, Sub: xPico SDK on Jan 2nd
 * Ok, once you get to the software, we can have a conversation on that.
 * The xPico Wi-Fi doesn’t have user interrupts. It’s a cooperative (non preemptive) multithreaded system.
 * We do have a way to register a callback function to when one of the CPs toggles. We also have some advanced triggering functionality so that you can set a thread to block waiting for a trigger. Then the callback function could message the trigger, which unblocks the thread that does the SPI transfer.
 * So in short, you can connect the ADC Data Ready to any available CP and use it as an “interrupt”.
 *
 * AB: For BIT, we can just wait in a finite loop and then declare Fail if no response recieved after sending a message
 *
 * */
/*
 *
 * ADC Interface Configuration
 *  - M0 = IOVDD = Asynchronous interrupt mode
 *   - M1 = GND = 24 bit device word
 *   - M2 = GND = Hamming code word validation off
 *
 *   - ADC Frame - 12 bytes
 *      | status| ADC 1 | ADC 2 | ADC 3 |
 *      | 24bit | 24bit | 24bit | 24bit |
 * 	status is in the upper 16 bits in 24bit device word size
 *
 * */
static void spiLoop(struct thread_info *ti)
{

    while(ti->isRunning)
    {
		if (setup_spi == false) {
			setup_spi = true;
			ltrx_thread_sleep(5000);
			//Send Unlock Command
			TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL,"SPI: Send Unlock Command(%x)", ADS131A04_UNCLOCK_COMMAND);
			sendCommand(ti, ADS131A04_UNCLOCK_COMMAND);

			//Send Wake-up Command
			TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL,"SPI: Send Wakeup Command(%x)", ADS131A04_WAKEUP_COMMAND);	
			sendCommand(ti, ADS131A04_WAKEUP_COMMAND);

			//Set Iclk divider to 2
			TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL,"SPI: Set Iclk divider to 2 Command(%x)", WRITE_REGISTER_COMMAND(CLK1, CLK_DIV_2));	
			sendCommand(ti, WRITE_REGISTER_COMMAND(CLK1, CLK_DIV_2));


			//high resolution mode, NO negative charge pump, internal reference; BIT5 is set because the User Guide mentions to always write 1 when writing to this register.
			TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL,"SPI: high resolution mode, NO negative charge pump, internal reference; BIT5 is set(%x)", (WRITE_REGISTER_COMMAND(A_SYS_CFG, HRM | INT_REFEN | BIT5)));
			sendCommand(ti, WRITE_REGISTER_COMMAND(A_SYS_CFG, HRM | INT_REFEN| BIT5));
	 
			//This is mainly to have everything have a fixed frame size from now on.
			TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL,"SPI: fixed frame size (%x)", WRITE_REGISTER_COMMAND(D_SYS_CFG, HIZDLY_12ns | DNDLY_12ns | FIXED));
			sendCommand(ti, WRITE_REGISTER_COMMAND(D_SYS_CFG, HIZDLY_12ns | DNDLY_12ns | FIXED));
	 
			//Enable All ADCs
			TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL,"SPI: Enable All ADCs(%x)", WRITE_REGISTER_COMMAND(ADC_ENA, ADC_ENA_ENABLE_ALL_CHANNELS));
			sendCommand_6words(ti, WRITE_REGISTER_COMMAND(ADC_ENA, ADC_ENA_ENABLE_ALL_CHANNELS));
	 
			//CRC is valid on all bits received and transmitted, 12 ns after assert DONE when LSB shifted out, CRC enabled
			//12 ns time that the device asserts Hi-Z on DOUT after the LSB of the data frame is shifted out.
			TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL,"SPI: CRC is valid on all bits received and transmitted, 12 ns after assert DONE when LSB shifted out, CRC enabled (%x)",
						WRITE_REGISTER_COMMAND(D_SYS_CFG, HIZDLY_12ns | DNDLY_12ns | CRC_MODE | CRC_EN | FIXED));
			sendCommand_6words(ti, WRITE_REGISTER_COMMAND(D_SYS_CFG, HIZDLY_12ns | DNDLY_12ns | CRC_MODE | CRC_EN | FIXED ));
		} else {
			
			TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "SPI is set rxBuffer =  \"%s\"", rxBuffer);
		}

		ltrx_thread_sleep(5000);
    }
}

static void spiThread(void *opaque)
{
    uint16_t zeroBasedIndex = (uint32_t)opaque;
    uint16_t spi = zeroBasedIndex + 1;
    bool loggedStartMessage = false;
    struct thread_info ti =
    {
        .zeroBasedIndex = zeroBasedIndex,
        .isRunning = true
    };
    s_threadInfo[zeroBasedIndex] = &ti;
    while(
        ti.isRunning &&
        ! ltrx_spi_open(zeroBasedIndex, 1000)
    );
    if(ti.isRunning)
    {
        TLOG(
            TLOG_SEVERITY_LEVEL__INFORMATIONAL,
            "%s started on SPI %u",
            s_spiProtocol.protocolName,
            spi
        );
        loggedStartMessage = true;
    }
    if(ti.isRunning)
    {
        spiLoop(&ti);
    }
    if(loggedStartMessage)
    {
        TLOG(
            TLOG_SEVERITY_LEVEL__INFORMATIONAL,
            "%s stopped on SPI %u",
            s_spiProtocol.protocolName,
            spi
        );
    }
    ltrx_spi_close(zeroBasedIndex);
    s_threadInfo[zeroBasedIndex] = NULL;
    s_threadForSpi[zeroBasedIndex] = 0;
}



bool StartSpiLog(uint16_t zeroBasedIndex)
{
    uint16_t spi = zeroBasedIndex + 1;
	zIndex=zeroBasedIndex;
    //struct ltrx_cpm_role s_role;

    ltrx_cp_register_role(&s_role);

    if(s_threadInfo[zeroBasedIndex] || s_threadForSpi[zeroBasedIndex])
    {
        TLOG(
            TLOG_SEVERITY_LEVEL__ERROR,
            "%s thread already running for SPI %u",
            s_spiProtocol.protocolName,
            spi
        );
        return false;
    }
    s_threadForSpi[zeroBasedIndex] = ltrx_thread_create(
        s_spiProtocol.protocolName,
        spiThread,
        (void *)(uint32_t)zeroBasedIndex,
        3000
    );
    if(! s_threadForSpi[zeroBasedIndex])
    {
        TLOG(
            TLOG_SEVERITY_LEVEL__ERROR,
            "Failed to create %s thread for SPI %u",
            s_spiProtocol.protocolName,
            spi
        );
        return false;
    }
    return true;
}

void StopSpiLog(uint16_t zeroBasedIndex)
{
    bool wasRunning = false;
    struct thread_info *ti;
    ltrx_preemption_block();
    ti = s_threadInfo[zeroBasedIndex];
    if(ti && ti->isRunning)
    {
        wasRunning = true;
        ti->isRunning = false;
    }
    ltrx_preemption_unblock();
    if(wasRunning)
    {
        struct ltrx_thread *lt;
        uint32_t tm = ltrx_timemark();
        while(
            (lt = s_threadForSpi[zeroBasedIndex]) != NULL &&
            lt != ltrx_thread_id() &&
            ltrx_elapsed_time_current_ms(tm) < 2000
        )
        {
            ltrx_thread_sleep(100);
        }
    }
}

/*!
** @}
*/

/*!
** @}
*/


