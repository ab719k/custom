
/*****************************************************************************/
/*                              Legal                                        */
/*****************************************************************************/

/*
** Copyright ©2015-2017. Lantronix, Inc. All Rights Reserved.
** By using this software, you are agreeing to the terms of the Software
** Development Kit (SDK) License Agreement included in the distribution package
** for this software (the “License Agreement”).
** Under the License Agreement, this software may be used solely to create
** custom applications for use on the Lantronix xPico Wi-Fi product.
** THIS SOFTWARE AND ANY ACCOMPANYING DOCUMENTATION IS PROVIDED "AS IS".
** LANTRONIX SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED
** TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS
** FOR A PARTICULAR PURPOSE.
** LANTRONIX HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
** ENHANCEMENTS, OR MODIFICATIONS TO THIS SOFTWARE.
** IN NO EVENT SHALL LANTRONIX BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
** SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
** ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
** LANTRONIX HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*****************************************************************************/
/*                           Documentation                                   */
/*****************************************************************************/

/*!
** \addtogroup example
** @{
*/

/*!
** \defgroup programmatic_scan programmatic_scan
** @{
**
** The \b programmatic_scan module demonstrates how to run a CLI command from
** your program and capture its output for program use.
**
** Build it from project "programmaticScanDemo".
*/

/*****************************************************************************/
/*                             Includes                                      */
/*****************************************************************************/

#include <stdio.h> /* MinGW plus Lantronix changes, delivered with SDK. */
#include <string.h> /* MinGW, delivered with SDK. */

#include "ltrx_compile_defines.h" /* Delivered with SDK. */
#include "ltrx_network.h" /* Delivered with SDK. */
#include "ltrx_stream.h" /* Delivered with SDK. */
#include "ltrx_tlog.h" /* Delivered with SDK. */
#include "programmatic_scan_module_defs.h" /* Automatically generated by make. */

/*****************************************************************************/
/*                              Defines                                      */
/*****************************************************************************/

#define CLI_SCAN_LINE_LENGTH 77

#define NETWORK_NAME_LENGTH 32

#define MAC_ADDRESS_LENGTH 6

/*****************************************************************************/
/*                             Structs                                       */
/*****************************************************************************/

struct output_stream_for_capture_scan
{
    bool passedHeaderDashedLine;
    bool scanCompleted;
    char scanLine[CLI_SCAN_LINE_LENGTH + 1];
    struct output_stream outStream;
};

/*****************************************************************************/
/*                         Local Constants                                   */
/*****************************************************************************/

static const uint32_t s_delayTimeInMilliseconds = 20000;

/*****************************************************************************/
/*                               Code                                        */
/*****************************************************************************/

static void processScanResults(
    const char *ssid,
    uint8_t *bssid,
    uint8_t channel,
    int rssi,
    const char *securitySuite
)
{
    TLOG(TLOG_SEVERITY_LEVEL__DEBUG, "SSID: %s", ssid);
    TLOG(
        TLOG_SEVERITY_LEVEL__DEBUG,
        "  BSSID: %02X:%02X:%02X:%02X:%02X:%02X",
        bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5]
    );
    TLOG(TLOG_SEVERITY_LEVEL__DEBUG, "  Channel: %u", channel);
    TLOG(TLOG_SEVERITY_LEVEL__DEBUG, "  RSSI: %d", rssi);
    TLOG(TLOG_SEVERITY_LEVEL__DEBUG, "  Security Suite: %s", securitySuite);
}

static void parseScanLine(const char *scanLine)
{
    char ssid[NETWORK_NAME_LENGTH + 1] = "";
    uint8_t bssid[MAC_ADDRESS_LENGTH];
    uint8_t channel;
    int rssi;
    char securitySuite[15];
    sscanf(
        scanLine,
        "%32c %hhx:%hhx:%hhx:%hhx:%hhx:%hhx %hhu %d dBm %14s",
        ssid,
        &bssid[0],
        &bssid[1],
        &bssid[2],
        &bssid[3],
        &bssid[4],
        &bssid[5],
        &channel,
        &rssi,
        securitySuite
    );
    /* Trim trailing blanks from ssid. */
    size_t ssidLength;
    for(
        ssidLength = strlen(ssid);
        ssidLength > 0 && ssid[ssidLength - 1] == ' ';
        --ssidLength
    )
    {
        ssid[ssidLength - 1] = 0;
    }
    processScanResults(ssid, bssid, channel, rssi, securitySuite);
}

static bool writeData(
    struct output_stream *outStream,
    const char *data, size_t length
)
{
    struct output_stream_for_capture_scan *osfcs;
    ASSIGN_STRUCT_POINTER_FROM_MEMBER_POINTER(
        osfcs, struct output_stream_for_capture_scan, outStream, outStream
    );
    size_t scannedLength = strlen(osfcs->scanLine);
    size_t writeLength = MINIMUM(length, CLI_SCAN_LINE_LENGTH - scannedLength);
    memcpy(osfcs->scanLine + scannedLength, data, writeLength);
    osfcs->scanLine[scannedLength + writeLength] = 0;
    ltrx_thread_yield();
    return true;
}

static bool writeNewline(struct output_stream *outStream)
{
    struct output_stream_for_capture_scan *osfcs;
    ASSIGN_STRUCT_POINTER_FROM_MEMBER_POINTER(
        osfcs, struct output_stream_for_capture_scan, outStream, outStream
    );
    if(osfcs->passedHeaderDashedLine)
    {
        if(! osfcs->scanCompleted)
        {
            if(osfcs->scanLine[0])
            {
                parseScanLine(osfcs->scanLine);
            }
            else
            {
                osfcs->scanCompleted = true;
            }
        }
    }
    else
    {
        size_t scannedLength = strlen(osfcs->scanLine);
        if(
            scannedLength >= NETWORK_NAME_LENGTH &&
            osfcs->scanLine[scannedLength - 1] == '-'
        )
        {
            osfcs->passedHeaderDashedLine = true;
        }
    }
    osfcs->scanLine[0] = 0;
    ltrx_thread_yield();
    return true;
}

static bool flushData(struct output_stream *outStream)
{
    (void)outStream;
    return true;
}

static bool outputClose(struct output_stream *outStream)
{
    (void)outStream;
    return true;
}

static void programmaticScanThread(void *opaque)
{
    (void)opaque;
    while(true)
    {
	    while(ltrx_ip_address_state(NETS_WLAN_START) == 0)
	    {
		    ltrx_thread_sleep(1000); /* wlan0 not up yet. */
	    }
        struct input_stream_from_const_char isfcc;
        struct output_stream_for_capture_scan osfcs =
        {
            .outStream.writeData = writeData,
            .outStream.writeNewline = writeNewline,
            .outStream.flushData = flushData,
            .outStream.outputClose = outputClose
        };
		if(ltrx_input_stream_init_from_const_char(&isfcc, "wlan scan\rexit\r"))
        {
			bool running = true;
            TLOG(TLOG_SEVERITY_LEVEL__DEBUG, "Starting scan.");
	        ltrx_cli_command_loop(
                &isfcc.inStream, &osfcs.outStream, &running, false
            );
            TLOG(TLOG_SEVERITY_LEVEL__DEBUG, "Scan completed.");
		}
		ltrx_input_stream_close(&isfcc.inStream);
        ltrx_thread_sleep(s_delayTimeInMilliseconds);
    }
}

void programmatic_scan_module_registration(void)
{
    ltrx_module_register(&g_programmatic_scanModuleInfo);
}

void programmatic_scan_module_startup(void)
{
    ltrx_thread_create(
        "Programatic Scan",
        programmaticScanThread,
        NULL,
        4000
    );
}

/*!
** @}
*/

/*!
** @}
*/
